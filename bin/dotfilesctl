#! /bin/env bash

# dotfiles management script

# Options
OPTION_SETUP=
OPTION_PACKAGES=()
OPTION_FORCE=0
REST_ARGS=

SETUPS=()
SETUP=
PACKAGES=()
PACKAGE=
FILES_IN_REPO_PATH=()
FILES_IN_REPO_PACKAGE=()

declare -A CONFIG
CONFIG[REPO_PATH]=

## HELPER FUNCTIONS ##

# Error display
err() {
  echo "ERROR: $@" >&2
}

# Get list of setups
get_setups() {
  for entry in $(command ls ${CONFIG[REPO_PATH]}); do
    [[ -d "${CONFIG[REPO_PATH]}"/$entry ]] && SETUPS[${#SETUPS[*]}]=$entry
  done
}

# Get list of packages for given setup
get_packages() {
  local repo_path=${CONFIG[REPO_PATH]}
  local setup=$1
  local pkg_dir=
  for entry in $(command ls "$repo_path/$setup"); do
    pkg_dir="$repo_path/$setup/$entry"
    [[ -d $pkg_dir ]] && PACKAGES[${#PACKAGES[*]}]=$entry
  done
}

array_contains() {
  local item=$1
  shift
  local arr=$@
  for i in ${arr[*]}; do
    [[ $item == $i ]] && return 0
  done
  return 1
}

assoc_array_has_key() {
  local assoc_arr_def=$(declare -p "$1")
  eval "declare -A local assoc_arr="${assoc_arr_def#*=} > /dev/null
  local key=$2
  [ -z ${assoc_arr[key]+"check"} ]
}

check_extra_args() {
  if [[ $# > 0 ]]; then
    err "Unrecognized extra arguments $@"
    return 1
  fi
}

read_config() {
  local CONFIG_FILE="${XDG_CONFIG_HOME:-$HOME/.config}"/dotfilesctl/config
  if [ -f $CONFIG_FILE ]; then
    IFS_BACKUP=$IFS
    while IFS='=' read key value; do
      IFS=$IFS_BACKUP
      assoc_array_has_key CONFIG REPO_PATH && CONFIG[$key]="$value"
    done < $CONFIG_FILE
  fi
}

check_repo_path() {
  [[ -n ${CONFIG[REPO_PATH]} ]] ||
  (
    err "Please configure REPO_PATH via dotfilesctl config REPO_PATH=/path/to/repo"
    return 99
  )
}

hostname() {
  [[ -f /etc/hostname ]] && cat /etc/hostname
}

path_relative_to_dir() {
  local dir=$(realpath $1)
  local path=$(realpath -s $2)
  if ! [[ ${path:0:${#dir}} == ${dir} ]]; then
    err "$2 is not (a file in) a subfolder of $1"
    return 1
  fi
  local substr=${path:${#dir}+1}
  if [[ -z $substr ]]; then
    err "You cannot track the entire HOME dir"
    return 1
  fi
  echo ${substr}
}

check_setup() {
  SETUP=${OPTION_SETUP:-$(hostname)}
  array_contains $SETUP ${SETUPS[*]}
  if [[ $? == 1 ]]; then
    err "$SETUP is not a valid setup"
    return 1
  fi
}

print_help_and_exit() {
  help
  exit ${1:-99}
}

arrayify() {
  tr ',' ' ' <<< $1
}

read_options() {
  local optstring=${1}
  shift
  while getopts ${optstring} optname; do
    case ${optname} in
      s)  OPTION_SETUP="$OPTARG";;
      p)  OPTION_PACKAGES=($(arrayify "$OPTARG"));;
      f)  OPTION_FORCE=1;;
      d)  OPTION_DRYRUN=1;;
      ?)  echo "Unknown option : $optname"
    esac
  done
  shift $(($OPTIND - 1))
  REST_ARGS=${*}
}

check_packages_validity() {
  local pos_params=(${*})
  for ((p_idx=0; p_idx<$#; p_idx++)); do
    local pkg=${pos_params[$p_idx]}
    array_contains $pkg ${PACKAGES[*]}
    if [[ $? == 1 ]]; then
      err "$pkg is not a valid package"
      return 1
    fi
  done
}  

check_package() {
  if [[ -z $PACKAGE ]]; then
    err "Missing required package param"
    return 1
  fi
}

get_files_in_repo() {
  local current_dir=
  local pkg_dir=
  local ls_rec_output=()
  local tmp=
  for package in $*; do
    pkg_dir="${CONFIG[REPO_PATH]}/${SETUP}/$package"
    ls_rec_output=($(command ls -RAB $pkg_dir))
    for ls_rec_item in ${ls_rec_output[*]}; do
      ((tmp=${#ls_rec_item}-1))
      if [[ ${ls_rec_item:$tmp} == ':' ]]; then
        current_dir=${ls_rec_item:0:$tmp}
      else
        tmp="${current_dir}/${ls_rec_item}"
        FILES_IN_REPO_PATH[${#FILES_IN_REPO_PATH[*]}]=${tmp:${#pkg_dir}+1}
        FILES_IN_REPO_PACKAGE[${#FILES_IN_REPO_PACKAGE[*]}]=${package}
      fi
    done
  done  
}

check_files() {
  local files=$@
  if [[ ${#files} == 0 ]]; then
    err "No files were provided"
    return 1
  fi
  for file in $files; do
    if ! ([[ -f $file ]] || [[ -d $file ]]); then
      err "$file is neither a file nor a directory"
      return 1
    fi &&
    path_relative_to_dir $HOME $file
  done
}

check_files_in_repo() {
  local files=$@
  if [[ ${#files} == 0 ]]; then
    err "No files were provided"
    return 1
  fi
  for file in $files; do
    if ! ([[ -f $file ]] || [[ -d $file ]]); then
      err "$file is neither a file nor a directory"
      return 1
    fi
    local rel_file="$(path_relative_to_dir $HOME $file)" &&
    for ((p=0; p<${#FILES_IN_REPO_PATH[*]};p++)); do
      if [[ ${FILES_IN_REPO_PATH[$p]} == $rel_file ]]; then
        return 0
      fi
    done
    err "$rel_file isn't tracked yet"
    return 1
  done
}

# Print given filepaths, one on each line
list_files() {
  echo ${*} | tr ' ' \\n | sort -u
}  

# Print file status
get_file_status() {
  local local_file="$HOME/$1" &&
  local repo_file="${CONFIG[REPO_PATH]}/$SETUP/$2/$1" &&
  if [[ ! -e $local_file ]]; then
    echo "  not deployed: $1"
  elif [[ -f $local_file ]] && [[ -d $repo_file ]]; then
    echo "  diff (not a dir): $1"
  elif [[ -d $local_file ]] && [[ -f $repo_file ]]; then
    echo "  diff (not a file): $1"
  elif [[ -f $local_file ]]; then
    if [[ ! -h $local_file ]] && [[ -h $repo_file ]]; then
      echo "  diff (not a symbolik link): $1"
    elif [[ -h $local_file ]] && [[ ! -h $repo_file ]]; then
      echo "  diff (not a regular file): $1"
    elif [[ ! -h $local_file ]]; then
      local local_file_hash=$(sha1sum $local_file | cut -d' ' -f1) &&
      local repo_file_hash=$(sha1sum $repo_file | cut -d' ' -f1) &&
      if [[ ! $local_file_hash == $repo_file_hash ]]; then
        echo "  diff: $1"
      fi
    else #symbolik links
      local local_file_link=$(readlink $local_file)
      local repo_file_link=$(readlink $repo_file)
      if [[ ! $local_file_link == $repo_file_link ]]; then
        echo "  diff (link diff): $1"
      fi
    fi
  fi
}

# Print files status
get_files_status() {
  echo "Local/repo files changes:" &&
  for file in ${*}; do
    get_file_status "$file" $(get_file_package "$file")
  done
}

get_file_package() {
  local target_package
  for ((p=0; p<${#FILES_IN_REPO_PATH[*]};p++)); do
    if [[ ${FILES_IN_REPO_PATH[$p]} == $1 ]]; then
      target_package=${FILES_IN_REPO_PACKAGE[$p]}
    fi
  done
  echo "$target_package"
}  

track_file() {
  local dest_dir="${CONFIG[REPO_PATH]}/$SETUP/$PACKAGE" &&
  local pkg="${1}" &&
  local check_if_in_other_pkg=${2:-0} &&
  local file="${3}" &&
  local rel_file="$(path_relative_to_dir $HOME $file)" &&
  local track_source=$(realpath -s "$file") &&
  local track_target=$(dirname "${dest_dir}/${rel_file}") &&
  if [[ $check_if_in_other_pkg == 1 ]]; then
    get_packages ${SETUP} &&
    get_files_in_repo ${PACKAGES[*]} &&
    local other_package=$(get_file_package $rel_file) &&
    if [[ ! $other_package == $pkg ]]; then
      err "File is already tracked in other package ($other_package)"
      return 4
    fi
  fi &&
  mkdir -p "${track_target}" &&
  cp -rd "$track_source" "$track_target" &&
  echo "Copied ${track_source} to ${track_target} ..."
}


## ACTIONS ##

# Action: help
# Displays usage
help() {
  cat << EOF
dotfiles management utility

Usage
  dotfilesctl status
  dotfilesctl setups
  dotfilesctl packages [-s <setup>]
  dotfilesctl ls [-s <setup>] [-p <package>...]
  dotfilesctl track [-s <setup>] <package> <file>...
  dotfilesctl add [-s <setup>] <file>...
  dotfilesctl deploy [-s <setup>] [-p <package>...] [-e <package>...] [-f]
  dotfilesctl checkout [-f] <file>...
  dotfilesctl backups
  dotfilesctl clone [-p <package>...] [-e <package>...] <source_setup> <target_setup>
  dotfilesctl [help [action]]

When <setup> is not provided, hostname is read instead, from /etc/hostname.
EOF
}

# Action: status
# Give basic info about configuration and lists diffs between repo and local files
status() {
  echo "Configured target repository: ${CONFIG[REPO_PATH]:-None}" &&
  local ls_packages=() &&
  read_options "s:" $* &&
  echo "Configured setup: ${CONFIG[SETUP]:-None}" &&
  set -- ${REST_ARGS} &&
  check_extra_args $* &&
  if [[ ! -z ${CONFIG[REPO_PATH]} ]]; then
    check_repo_path &&
    get_setups &&
    check_setup &&
    get_packages $SETUP &&
    ls_packages=${PACKAGES[*]} &&
    get_files_in_repo ${ls_packages[*]} &&
    get_files_status ${FILES_IN_REPO_PATH[*]}
  fi
} 

# Action: list-setups
# List available setups
setups() {
  check_extra_args $* &&
  get_setups &&
  echo $SETUPS
}

# Action: list-packages
# List available packages in given setup
packages() {
  read_options "s:" $* &&
  set -- ${REST_ARGS} &&
  check_extra_args $* &&
  get_setups &&
  check_setup &&
  get_packages $SETUP &&
  echo ${PACKAGES[*]}
}

# Action: ls
# List dotfiles paths
ls() {
  local ls_packages=()
  read_options "s:p:" $* &&
  set -- ${REST_ARGS} &&
  check_extra_args $* &&
  get_setups &&
  check_setup &&
  if [[ ${#OPTION_PACKAGES[*]} > 0 ]]; then
    get_packages $SETUP
    check_packages_validity ${OPTION_PACKAGES[*]} &&
    ls_packages=${OPTION_PACKAGES[*]}
  else
    get_packages $SETUP &&
    ls_packages=${PACKAGES[*]}
  fi &&
  get_files_in_repo ${ls_packages[*]} &&
  list_files ${FILES_IN_REPO_PATH[*]}
}

# Action: track
# Copies one or many files from the HOME dir to a specific package and setup in the repo.
track() {
  read_options "s:d" $* &&
  set -- ${REST_ARGS} &&
  get_setups &&
  check_setup &&
  PACKAGE=$1 &&
  shift &&
  get_packages $SETUP &&
  check_package &&
  check_files $@ &&
  for file in $@; do
    track_file "${PACKAGE}" 1 "$file"
  done
}

# Action: add
# Does the same as track on files that are already tracked
# thus it's not necessary to provide the package.
add() {
  read_options "s:" $* &&
  set -- ${REST_ARGS} &&
  get_setups &&
  check_setup &&
  get_packages ${SETUP} &&
  get_files_in_repo ${PACKAGES[*]} &&
  check_files_in_repo $@ &&
  for file in $@; do
    local pkg=$(get_file_package "${file}") &&
    track_file "${pkg}" 0 "${file}" 
  done
}

# Entry point
main() {
  # Read config file
  read_config
  # Retrieve action from params and launch function
  local ACTION=${1:-help}
  shift
  case $ACTION in
    status | config | help)
      $ACTION $@ || print_help_and_exit $?
      ;;
    setups | packages | ls | track | add | checkout | deploy | backups | clone | config)
      check_repo_path &&
      $ACTION $@ || print_help_and_exit $?
      ;;
    *)
      err "$ACTION is not a valid action."
      print_help_and_exit 2
      ;;
  esac
}

main $@
